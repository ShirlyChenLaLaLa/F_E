{"remainingRequest":"/Users/yuhanchen/repos/F_E/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/yuhanchen/repos/F_E/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/yuhanchen/repos/F_E/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yuhanchen/repos/F_E/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yuhanchen/repos/F_E/docs/js/events.md?vue&type=template&id=3d7666dc&","dependencies":[{"path":"/Users/yuhanchen/repos/F_E/docs/js/events.md","mtime":1548837290214},{"path":"/Users/yuhanchen/repos/F_E/node_modules/cache-loader/dist/cjs.js","mtime":1547801009313},{"path":"/Users/yuhanchen/repos/F_E/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1547801010156},{"path":"/Users/yuhanchen/repos/F_E/node_modules/cache-loader/dist/cjs.js","mtime":1547801009313},{"path":"/Users/yuhanchen/repos/F_E/node_modules/vue-loader/lib/index.js","mtime":1547801010156},{"path":"/Users/yuhanchen/repos/F_E/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1547801017119}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h3 id=\\\"事件的一些小知识\\\"><a href=\\\"#事件的一些小知识\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件的一些小知识</h3> <h4 id=\\\"dom事件流包括三个阶段。\\\"><a href=\\\"#dom事件流包括三个阶段。\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> DOM事件流包括三个阶段。</h4> <ol><li>事件捕获阶段</li> <li>处于目标阶段</li> <li>事件冒泡阶段</li></ol> <h4 id=\\\"事件冒泡\\\"><a href=\\\"#事件冒泡\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件冒泡</h4> <p>事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。\\n举个栗子，就很容易明白了。\\nbutton  -&gt;  body  -&gt; document -&gt; window</p> <h4 id=\\\"事件捕获\\\"><a href=\\\"#事件捕获\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件捕获</h4> <p>事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。\\nwindow  -&gt;  document  -&gt; body -&gt; button</p> <h4 id=\\\"事件委托\\\"><a href=\\\"#事件委托\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件委托</h4> <p>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code>\\n<span class=\\\"token keyword\\\">var</span> btn6 <span class=\\\"token operator\\\">=</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">&quot;btn6&quot;</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ndocument<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function-variable function\\\">onclick</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>event<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  event <span class=\\\"token operator\\\">=</span> event <span class=\\\"token operator\\\">||</span> window<span class=\\\"token punctuation\\\">.</span>event<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">var</span> target <span class=\\\"token operator\\\">=</span> event<span class=\\\"token punctuation\\\">.</span>target <span class=\\\"token operator\\\">||</span> event<span class=\\\"token punctuation\\\">.</span>srcElement<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>target <span class=\\\"token operator\\\">==</span> btn6<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span>btn5<span class=\\\"token punctuation\\\">.</span>value<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n</code></pre></div><p>优点：</p> <ol><li>提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。</li> <li>可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适</li></ol> <p>缺点：</p> <ol><li>事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件。</li></ol>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}