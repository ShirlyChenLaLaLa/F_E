(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{172:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h3",{attrs:{id:"事件的一些小知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件的一些小知识","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件的一些小知识")]),t._v(" "),e("h4",{attrs:{id:"dom事件流包括三个阶段。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom事件流包括三个阶段。","aria-hidden":"true"}},[t._v("#")]),t._v(" DOM事件流包括三个阶段。")]),t._v(" "),e("ol",[e("li",[t._v("事件捕获阶段")]),t._v(" "),e("li",[t._v("处于目标阶段")]),t._v(" "),e("li",[t._v("事件冒泡阶段")])]),t._v(" "),e("h4",{attrs:{id:"事件冒泡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件冒泡")]),t._v(" "),e("p",[t._v("事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。\n举个栗子，就很容易明白了。\nbutton  ->  body  -> document -> window")]),t._v(" "),e("h4",{attrs:{id:"事件捕获"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件捕获")]),t._v(" "),e("p",[t._v("事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。\nwindow  ->  document  -> body -> button")]),t._v(" "),e("h4",{attrs:{id:"事件委托"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件委托","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件委托")]),t._v(" "),e("p",[t._v("事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。")])])}],!1,null,null,null);s.options.__file="events.md";a.default=s.exports}}]);